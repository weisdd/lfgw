package lfgw

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"

	"github.com/VictoriaMetrics/metrics"
	"github.com/rs/zerolog/hlog"
	"github.com/weisdd/lfgw/internal/querymodifier"
)

type contextKey string

const contextKeyACL = contextKey("acl")

var requestsTotal = metrics.NewCounter("requests_total")
var federateDuration = metrics.NewSummary(`request_duration_seconds{path="/federate"}`)
var queryDuration = metrics.NewSummary(`request_duration_seconds{path="/api/v1/query"}`)
var queryRangeDuration = metrics.NewSummary(`request_duration_seconds{path="/api/v1/query_range"}`)

// nonProxiedEndpointsMiddleware is a workaround to support healthz, metrics, and favicon.ico endpoints while forwarding everything else to an upstream.
func (app *application) nonProxiedEndpointsMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case "/healthz":
			w.WriteHeader(http.StatusOK)
			_, _ = w.Write([]byte("OK"))
			return
		case "/metrics":
			metrics.WritePrometheus(w, true)
			return
		default:
			next.ServeHTTP(w, r)
		}
	})
}

// logAndMetricsMiddleware updates metrics, populates zerolog context with additional fields that are used in log entries generated by other middlewares and optionally generates access logs.
func (app *application) logAndMetricsMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		next = hlog.RequestIDHandler("req_id", "Request-Id")(next)

		if app.Debug {
			err := r.ParseForm()
			if err != nil {
				app.clientError(w, http.StatusBadRequest)
				return
			}

			// Once r.ParseForm() is called, we need to update ContentLength, otherwise the request will fail. r.PostForm contains data for PATCH, POST, and PUT requests.
			postForm := r.PostForm.Encode()
			newBody := strings.NewReader(postForm)
			r.ContentLength = newBody.Size()
			r.Body = io.NopCloser(newBody)

			// If any of those are empty, they won't get logged
			app.enrichDebugLogContext(r, "get_params", app.unescapedURLQuery(r.URL.Query().Encode()))
			app.enrichDebugLogContext(r, "post_params", app.unescapedURLQuery(postForm))

			// Workaround to make further r.ParseForm() calls update r.Form and r.PostForm again, might be useful in case there's another middleware before rewriteRequestMiddleware
			r.Form = nil
			r.PostForm = nil
		}

		next = hlog.AccessHandler(func(r *http.Request, status, size int, duration time.Duration) {
			// Generate access / debug logs
			if app.LogRequests || app.Debug {
				// TODO: optionally change to debug?
				hlog.FromRequest(r).Info().
					Str("method", r.Method).
					Stringer("url", r.URL).
					Int("status", status).
					Int("size", size).
					Dur("duration", duration).
					Msg("")
			}

			// Update metrics
			requestsTotal.Inc()

			d := duration.Seconds()
			switch r.URL.Path {
			case "/federate":
				federateDuration.Update(d)
			case "/api/v1/query":
				queryDuration.Update(d)
			case "/api/v1/query_range":
				queryRangeDuration.Update(d)
			}

		})(next)

		next.ServeHTTP(w, r)
	})
}

// safeModeMiddleware forbids access to some API endpoints if safe mode is enabled.
func (app *application) safeModeMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if app.SafeMode && app.isUnsafePath(r.URL.Path) {
			hlog.FromRequest(r).Error().Caller().
				Msgf("Blocked a request to %s", r.URL.Path)
			app.clientError(w, http.StatusForbidden)
			return
		}

		next.ServeHTTP(w, r)
	})
}

// proxyHeadersMiddleware sets proxy headers.
func (app *application) proxyHeadersMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if app.SetProxyHeaders {
			r.Header.Set("X-Forwarded-For", r.RemoteAddr)
			r.Header.Set("X-Forwarded-Proto", r.URL.Scheme)
			r.Header.Set("X-Forwarded-Host", r.Header.Get("Host"))
		}

		next.ServeHTTP(w, r)
	})
}

// oidcModeMiddleware verifies a jwt token, and, if valid and authorized,
// adds a respective label filter to the request context.
func (app *application) oidcModeMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		rawAccessToken, err := app.getRawAccessToken(r)
		if err != nil {
			// Might produce plenty of error messages, though it will make it much easier to understand why requests are failing
			hlog.FromRequest(r).Error().Caller().
				Err(err).Msg("")

			app.clientErrorMessage(w, http.StatusUnauthorized, err)
			return
		}

		ctx := r.Context()
		accessToken, err := app.verifier.Verify(ctx, rawAccessToken)
		if err != nil {
			// Better to log to see token verification errors
			hlog.FromRequest(r).Error().Caller().
				Err(err).Msg("")
			app.clientErrorMessage(w, http.StatusUnauthorized, err)
			return
		}

		// Extract custom claims
		var claims struct {
			Roles []string `json:"roles"`
			Email string   `json:"email"`
			// Username string   `json:"preferred_username"`
		}
		if err := accessToken.Claims(&claims); err != nil {
			// Claims not set, bad token
			hlog.FromRequest(r).Error().Caller().
				Err(err).Msg("")
			app.clientErrorMessage(w, http.StatusUnauthorized, err)
			return
		}

		app.enrichLogContext(r, "email", claims.Email)
		// NOTE: The field will contain all roles present in the token, not only those that are considered during ACL generation process
		app.enrichDebugLogContext(r, "roles", strings.Join(claims.Roles, ", "))

		acl, err := app.ACLs.GetUserACL(claims.Roles, app.AssumedRolesEnabled)
		if err != nil {
			hlog.FromRequest(r).Error().Caller().
				Err(err).Msg("")
			app.clientErrorMessage(w, http.StatusUnauthorized, err)
			return
		}

		app.enrichDebugLogContext(r, "label_filter", string(acl.LabelFilter.AppendString(nil)))

		ctx = context.WithValue(ctx, contextKeyACL, acl)
		r = r.WithContext(ctx)

		next.ServeHTTP(w, r)
	})
}

// rewriteRequestMiddleware rewrites a request before forwarding it to the upstream.
func (app *application) rewriteRequestMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// TODO: rewrite?
		if app.UpstreamURL == nil {
			app.serverError(w, r, fmt.Errorf("UpstreamURL is not initialized"))
			return
		}

		// Rewrite request destination
		r.Host = app.UpstreamURL.Host

		acl, ok := r.Context().Value(contextKeyACL).(querymodifier.ACL)
		if !ok {
			// Should never happen. It means OIDC middleware hasn't done it's job
			app.serverError(w, r, fmt.Errorf("ACL is not set in the context"))
			return
		}

		if app.isNotAPIRequest(r.URL.Path) {
			hlog.FromRequest(r).Debug().Caller().
				Msg("Not an API request, request is not modified")
			next.ServeHTTP(w, r)
			return
		}

		if acl.Fullaccess {
			hlog.FromRequest(r).Debug().Caller().
				Msg("User has full access, request is not modified")
			next.ServeHTTP(w, r)
			return
		}

		err := r.ParseForm()
		if err != nil {
			app.clientError(w, http.StatusBadRequest)
			return
		}

		qm := querymodifier.QueryModifier{
			ACL:                 acl,
			EnableDeduplication: app.EnableDeduplication,
			OptimizeExpressions: app.OptimizeExpressions,
		}

		// Adjust GET params
		newGetParams, err := qm.GetModifiedEncodedURLValues(r.URL.Query())
		if err != nil {
			hlog.FromRequest(r).Error().Caller().
				Err(err).Msg("")
			app.clientError(w, http.StatusBadRequest)
			return
		}
		r.URL.RawQuery = newGetParams
		app.enrichDebugLogContext(r, "new_get_params", app.unescapedURLQuery(newGetParams))

		// For PATCH, POST, and PUT requests
		newPostParams, err := qm.GetModifiedEncodedURLValues(r.PostForm)
		if err != nil {
			hlog.FromRequest(r).Error().Caller().
				Err(err).Msg("")
			app.clientError(w, http.StatusBadRequest)
			return
		}
		newBody := strings.NewReader(newPostParams)
		r.ContentLength = newBody.Size()
		r.Body = io.NopCloser(newBody)
		// TODO: the field name is slightly misleading, should, probably, be renamed
		app.enrichDebugLogContext(r, "new_post_params", app.unescapedURLQuery(newPostParams))

		// Workaround to make further r.ParseForm() calls update r.Form and r.PostForm again, might be useful in case there's another middleware before rewriteRequestMiddleware
		r.Form = nil
		r.PostForm = nil

		next.ServeHTTP(w, r)
	})
}
